from typing import List, Any, Tuple, Union, Optional

import pandas as pd

from . import constants as pkg_const
from dataframes.columns import n_pattern


def increment_ids(
        tuple_list: List[Tuple[int, Any]],
        increment: int
        ) -> List[Tuple[int, Any]]:
    """
    For tuples containing an index as first element and an arbitrary number of
    elements following, increment the index by a specified amount.

    Args:
        tuple_list (List[Tuple[int, Any]]): A list of tuples where the first
            element is an index and the remaining elements are data.
        increment (int): The amount by which to increment the index.

    Returns:
        List[Tuple[int, Any]]: A list of tuples where each index has been
        incremented by the specified amount.
    """
    return [(idx + increment, *e) for idx, *e in tuple_list]


def add_id(elements: List[Any]) -> List[Tuple[int, Any]]:
    """
    Add an index to each element in the list. If the elements are tuples, the
    index is included as the first element in the tuple. Otherwise, returns a
    list of tuples where the first element is the index and the second element
    is the corresponding element from the input list.

    Args:
        elements (List[Any]): A list of elements of any type.
    Returns:
        List[Tuple[int, Any]]: A list of tuples where each tuple contains an
        index (int) and the corresponding element from the input list.
    """
    if all(isinstance(e, tuple) for e in elements):
        return [(idx, *e) for idx, e in enumerate(elements)]
    else:
        return list(enumerate(elements))


def clean_placeholders(
        data: Union[pd.DataFrame, List[str], List[tuple]],
        column: Optional[str] = None,
        placeholders: List[str] = pkg_const.PLACEHOLDERS)\
        -> Union[pd.DataFrame, List[str], List[tuple]]:
    """
    Remove placeholders from text_unit data. If data is a pandas dataframe, a
    column must be specified.

    If the dataframe contains a column with segment counts of the format
    generated by the TextSplitter class, the counts will be recalculated after
    removing placeholders.

    Args:
        data (Union[pd.DataFrame, List[str], List[tuple]]): Data to be cleaned.
        column (Optional[str]): Column containing data in a pandas dataframe.
        placeholders (List[str]): List of strings to be removed from data.

    Returns:
        Union[pd.DataFrame, List[str], List[tuple]]: Cleaned data with
            placeholders removed.
    """
    if isinstance(data, pd.DataFrame):
        if column is None:
            raise ValueError("Column must be specified for pandas dataframes.")

        output_df = data[~data[column].isin(placeholders)]

        # recount segments
        if n_pattern(column) in output_df:
            output_df[n_pattern(column)] = (output_df.groupby("file")["file"]
                                            .transform("size"))

        output_df = output_df.reset_index(drop=True)

        return output_df

    elif isinstance(data, list):
        return [p for p in data if p not in placeholders]

    elif isinstance(data, list) and isinstance(data[0], tuple):
        return [p for p in data if p[1] not in placeholders]

    else:
        raise ValueError("Data must be a pandas dataframe, list of strings or "
                         "list of tuples.")


def find_substring_indices(
        text: str,
        substrings: List[str]
        ) -> List[Tuple[int, int]]:
    """
    Find the start and end indices of a list of substrings in a text.

    Args:
        text (str): Text to search for substrings.
        substrings (List[str]): List of substrings to search for in text.

    Returns:
        List[Tuple[int, int]]: List of tuples containing start and end indices
            of each substring in text.
    """
    indices = []
    start = 0

    for substring in substrings:
        start = text.find(substring, start)
        if start == -1:
            raise ValueError(f"Substring '{substring}' not found in text.")
        end = start + len(substring)
        indices.append((start, end))
        start = end  # Move start to the end of the current substring for the next search

    return indices

def uniform_depth(obj: Any) -> int:
    """Return the depth of an object of nested lists. "Depth" signifies how many
    times you can uniformly peel away layers of lists before hitting a non-list
    element that can't be peeled any further. If it's not a list at all, the
    depth is 0.

    Examples:
    - [['foo'], ['bar']] -> 2
      (layer #1 is a list of lists, layer #2 is a list of strings, so we stop)
    - [['foo'], 'bar'] -> 1
      (layer #1: not all subelements are lists, so we stop immediately)
    - [] -> 1
      (layer #1 is a list, but it’s empty; we can’t go deeper)
    - 'foo' -> 0
      (not even a list)
    """
    depth = 0
    while isinstance(obj, list):
        depth += 1
        if not obj:  # empty list
            break
        # Check if all subelements are lists, then peel away list layer by
        # flattening them all
        if all(isinstance(sub, list) for sub in obj):
            obj = [item for sub in obj for item in sub]
        else:
            break
    return depth
